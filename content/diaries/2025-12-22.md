---
title: 学习 useOverlay 源码 
date: 2025-12-22
---

## Q?

useOverlay 如何解决弹窗回掉的问题的？

## A!

参考源码 [useOverlay](https://github.com/nuxt/ui/blob/v3/src/runtime/composables/useOverlay.ts)

```ts
// 伪代码
const overlays = [{id: xxx, open}]

function open(id) {
  const overlay = getOverlay(id)
  overlay.isOpen = true
  overlay.isMounted = true
  const result = new Promise<any>(resolve => overlay.resolvePromise = resolve)

  return Object.assign(result, {
    id: xxx,
    result,
  })
}

const close = (id: symbol, value?: any): void => {
  const overlay = getOverlay(id)

  overlay.isOpen = false

  // Resolve the promise if it exists
  if (overlay.resolvePromise) {
    overlay.resolvePromise(value)
    overlay.resolvePromise = undefined
  }
}

open() // 只需要打开即可
await overlay.open() // 想要回调处理
```


可以看 nuxt/ui 的源码实现，真的封装的非常好

```ts
function _useOverlay() {
  const overlays = shallowReactive<Overlay[]>([])

  const create = <T extends Component>(component: T, _options?: OverlayOptions<ComponentProps<T>>): OverlayInstance<T> => {
    const { props, defaultOpen, destroyOnClose } = _options || {}

    const options = reactive<Overlay>({
      id: Symbol(import.meta.dev ? 'useOverlay' : ''),
      isOpen: !!defaultOpen,
      component: markRaw(component!),
      isMounted: !!defaultOpen,
      destroyOnClose: !!destroyOnClose,
      originalProps: props || {},
      props: { ...props }
    })

    overlays.push(options)

    return {
      ...options,
      open: <T extends Component>(props?: ComponentProps<T>) => open(options.id, props),
      close: value => close(options.id, value),
      patch: <T extends Component>(props: Partial<ComponentProps<T>>) => patch(options.id, props)
    }
  }

  const open = <T extends Component>(id: symbol, props?: ComponentProps<T>): OpenedOverlay<T> => {
    const overlay = getOverlay(id)

    // If props are provided, merge them with the original props, otherwise use the original props
    if (props) {
      overlay.props = { ...overlay.originalProps, ...props }
    } else {
      overlay.props = { ...overlay.originalProps }
    }

    overlay.isOpen = true
    overlay.isMounted = true
    const result = new Promise<any>(resolve => overlay.resolvePromise = resolve)

    return Object.assign(result, {
      id,
      isMounted: overlay.isMounted,
      isOpen: overlay.isOpen,
      result
    })
  }

  const close = (id: symbol, value?: any): void => {
    const overlay = getOverlay(id)

    overlay.isOpen = false

    // Resolve the promise if it exists
    if (overlay.resolvePromise) {
      overlay.resolvePromise(value)
      overlay.resolvePromise = undefined
    }
  }

  const closeAll = (): void => {
    overlays.forEach(overlay => close(overlay.id))
  }

  const unmount = (id: symbol): void => {
    const overlay = getOverlay(id)

    overlay.isMounted = false

    if (overlay.destroyOnClose) {
      const index = overlays.findIndex(overlay => overlay.id === id)
      overlays.splice(index, 1)
    }
  }

  const patch = <T extends Component>(id: symbol, props: Partial<ComponentProps<T>>): void => {
    const overlay = getOverlay(id)

    overlay.props = { ...overlay.props, ...props }
  }

  const getOverlay = (id: symbol): Overlay => {
    const overlay = overlays.find(overlay => overlay.id === id)

    if (!overlay) {
      throw new Error('Overlay not found')
    }

    return overlay
  }

  const isOpen = (id: symbol): boolean => {
    const overlay = getOverlay(id)

    return overlay.isOpen
  }

  return {
    overlays,
    open,
    close,
    closeAll,
    create,
    patch,
    unmount,
    isOpen
  }
}

export const useOverlay = /* @__PURE__ */ createSharedComposable(_useOverlay)
```

